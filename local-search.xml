<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go defer+闭包的一个小坑</title>
    <link href="/2024/06/07/go-defer-closure/"/>
    <url>/2024/06/07/go-defer-closure/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-defer-闭包的一个小坑"><a href="#Go-defer-闭包的一个小坑" class="headerlink" title="Go defer+闭包的一个小坑"></a>Go defer+闭包的一个小坑</h1><p>今天在写代码的时候，发现一个奇怪的事情，在将无效的逻辑简化之后，可以总结出这样的一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer only: &quot;</span> + a)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer closure: &quot;</span> + a) &#125;()<br><br>a = <span class="hljs-string">&quot;2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>先让我们想一想，这段代码的输出是什么？我的之前的理解中，显然，这是问 defer 的执行顺序问题，那太简单了，毫无疑问应该输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">defer closure: 1<br>defer only: 1<br></code></pre></td></tr></table></figure><p>然而，真的执行这段代码之后，我惊讶的发现，真实的输出是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">defer closure: 2<br>defer only: 1<br></code></pre></td></tr></table></figure><p>这就有些让我费解了，正好借着这个机会，我对 defer&amp; 闭包做了一次系统的整理。</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><h3 id="预计算"><a href="#预计算" class="headerlink" title="预计算"></a>预计算</h3><p>Go 官方文档对此由如下<a href="">阐述</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go Vendor-时代的眼泪</title>
    <link href="/2024/05/22/go-vendor/"/>
    <url>/2024/05/22/go-vendor/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Vendor"><a href="#Go-Vendor" class="headerlink" title="Go Vendor"></a>Go Vendor</h1><p>go vendor 也算时代的眼泪了，在 go1.5～1.11 之间被相对广泛的使用，在 1.11之后基本就退出历史舞台了，原因无他，go module 太好用了。 即便政治正确一点地说，它和 cargo、bazel 相比功能上没有那么丰富，但其轻量、简便在包管理工具中也难寻其右。</p><p>事实上，在我 21 年开始接触 Go 时，主流 Go 版本已经来到 1.16，因此我从未接触过 vendor 项目， 甚至连 GOPATH 也不用太了解。 不过，既然是时代的眼泪，vendor 就一定还留着其泪痕。</p><p>跳槽之后，新工作的核心仓库，是一个 14 年就开始的古老项目，现在还留着不少针对 go1.5 的条件编译代码和汇编。此仓库主打一个历史悠久， 历经古法包管理（直接复制仓库）、bazel、vendor 等多个模式，并且由于这些模式的混杂导致至今未能升级到 go module，此外， go 版本也停留在 go1.12，主要也没啥人敢升，一来没产出，二来容易出问题。虽说程序员和代码有一个能跑就行，但现在的大环境，程序员怕是不太好跑。</p><p>因此，为了开发这个仓库，我对 go vendor 进行了相对深入的了解，记录一下。</p><h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>GOPATH 是「标记 Go 代码工作区」的环境变量，一般来说，GOPATH 下应该有三个子文件夹：bin、pkg、src，对应了主要的三个功能：</p><ul><li>标记 go 二进制地址。通过 go install&#x2F;go get 安装的二进制文件，会放在 $GOPATH&#x2F;bin 中，此规范始终是生效的。</li><li>标记依赖包地址。在启用 go module 之后，go module 会将下载的依赖包放到 $GOPATH&#x2F;pkg 中，并且加上版本 tag 以及 sum 信息。自然，此规范是在启用 go module 之后才有效。</li><li>标记源码地址。这个主要是针对 vendor 模式，在下面会细讲，在 module 模式下已经事实上不再需要了吗，也不再有目录规范，当前源码想放哪就放哪，不过通常会基于历史习惯放到 src 下，但比如 Goland 新建项目则会默认放到 GolandProject 下。</li></ul><p>简单总结下：在 module 模式下，GOPATH 下的两个主要功能：bin&amp;pkg 都是由 go tools 自动管理的，对于程序员而言几乎不再需要被关注。</p><h2 id="Vendor"><a href="#Vendor" class="headerlink" title="Vendor"></a>Vendor</h2><p>Vendor 模式是在 Go 早期没有包管理的野蛮发展下形成的一个社区实践，并在 1.5 被正式纳入语言特性，1.13 结束生命周期。 Vendor 其实很简单，和 node_modules 差不太多，本质上都是「约定一个目录存放第三方包」，这个目录便是 vendor。</p><p>让我们以一个例子开始。假如你创建了一个项目，这个项目目前为止只使用了标准库，我们知道标准库在 GOROOT 下保存，那么，你们的代码只需要在 GOPATH&#x2F;src 下挂着就行了，当然，原则上来说你挂哪都行，甚至根目录也无所谓，大不了临时改一下 $GOPATH。</p><p>不过，我们都是习惯良好的工程师，为了方便管理手上的诸多项目，我们决定固定 GOPATH，并且按照项目名称进行良好的目录层级划分，就像 JAVA 那样（先让我们这么做，后面我们会明白这么做的好处的，良好的习惯总是会有回报的），我们假定这个项目叫 github.com&#x2F;hyphennn&#x2F;proj1，于是，你的目录如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">$GOPATH<br>    - bin<br>    - src<br>        - github.com<br>            - hyphennn<br>                - proj1 // 下面的层级是你的源代码<br></code></pre></td></tr></table></figure><p>接下来，让我们迭代这个项目，以及项目中的包管理机制</p><h3 id="版本一-GOPATH-机制"><a href="#版本一-GOPATH-机制" class="headerlink" title="版本一 GOPATH 机制"></a>版本一 GOPATH 机制</h3><p>现在，我们决定引入某一个功能，这个功能我们曾经写过，只不过在 github.com&#x2F;hyphennn&#x2F;proj2 这个项目中，假定代码在 github.com&#x2F;hyphennn&#x2F;proj2&#x2F;waibiwaibi&#x2F;waibibabo.go 这个文件里面，自然地，复制过去是个好想法，但假如这个文件依赖了项目中的其他文件呢？都复制过去吗？要是变量名、方法名有冲突咋办？更进一步的，以后 proj2 继续迭代，难道改一次代码就复制一次吗？这显然不合理。事实上，Go 提供了解决方案，你可以如下组织你的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">$GOPATH<br>    - bin<br>    - src<br>        - github.com<br>            - hyphennn<br>                - proj1 // 下面的层级是你的源代码<br>                - proj2<br></code></pre></td></tr></table></figure><p>这样，你只需要 import 一下就好了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/hyphennn/proj2/waibiwaibi&quot;</span><br></code></pre></td></tr></table></figure><p>这种方式是很直观的，因为你引用项目内其他文件夹时你也是这么做的，当项目中被声明 import “xxx” 时，编译器会去寻找 GOPATH&#x2F;src&#x2F;xxx，如果找到，就会将其作为依赖库加入编译。当然，会优先在 $GOROOT 下找标准库。</p><p>项目跑的很不错，现在该添加新的功能了。功能太复杂，人力成本非常有限，不过好消息是我们找到了两个来自互联网的包，帮助我们解决了问题，他们分别是：github.com&#x2F;helper1&#x2F;pkg1 和 golang.org&#x2F;helper2&#x2F;pkg2。怎么把这两个包引入呢？一个很直观的思路就是：像使用我们自己的项目一样使用这两个包，参照一下上面 import 寻找目标的原理，我们能很轻易的给出如下目录：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">$GOPATH<br>    - bin<br>    - src<br>        - github.com<br>            - hyphennn<br>                - proj1 // 下面的层级是你的源代码<br>                - proj2<br>            - helper1<br>                - pkg1<br>        - golang.org<br>            - helper2<br>                -pkg2<br></code></pre></td></tr></table></figure><p>同样的，import 语句如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;github.com/hyphennn/proj2/waibiwaibi&quot;</span><br>    <span class="hljs-string">&quot;github.com/helper1/pkg1&quot;</span> <span class="hljs-comment">// 让我们省略掉后面的子目录，毕竟都差不多</span><br>    <span class="hljs-string">&quot;golang.org/helper2/pkg2&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>尝试一下，运行良好，以后就这么干，可以不断引入新的包。</p><p>到此为止，我们完成了第一版的包管理机制，严格来说并不叫包管理，因为它完全依赖 GOPATH，不过这不重要，我们的项目很棒，赚大钱了(bushi</p><h3 id="版本二-Vendor-机制"><a href="#版本二-Vendor-机制" class="headerlink" title="版本二 Vendor 机制"></a>版本二 Vendor 机制</h3><p>如果你了解过包管理工具，以及构建工程，显然，GOPATH 不是个好的方案，它至少有如下缺点：</p><ul><li>自己编写的包，和网络上的第三方包，都放置在GOPATH&#x2F;src下，容易造成混乱，不方便管理。</li><li>项目中用到的依赖包，都需要手动go get下载，大项目来说非常麻烦</li><li>如果引入的三方包中又引入了其他三方包，就不好处理了，需要找到以后，使用go get去下载。</li><li>go get没有版本的概念，团队合作中，很容易出现使用了不同版本的包，造成不必要的错误。</li><li>协作开发时，需要统一各个开发成员本地$GOPATH&#x2F;src下的依赖包。</li><li>引用的包引用了已经转移的包，而作者没改的话，需要自己修改引用。</li></ul><p>让我们想想别的工具怎么解决的。Go 作为世界上第二好的语言，不妨学习下世界上最好的语言-PHP。PHP 使用 Composer 作为包管理器，将第三方包放到根目录下的一个名为 vendor 的目录下。好主意，让我们融会贯通下，制订 Go 的 vendor 机制。</p><blockquote><p>当然，需要指出的是，我根本不清楚 Go Vendor 的起源，以上只是为了告诉大家世界上最好的语言是 PHP。</p></blockquote><p>首先，我们把要求团队把所有的依赖包都放到一个叫做 vendor 的目录，这一步有点像 js 著名（<del>臭名昭著</del>）的 node_modules。不过，由于不同域名、仓库组下的仓库是可以同名的，因此，我们仍然要求在 vendor 下按照层级放置依赖包（就像 GOPATH 里面的那样）。由此，我们解决了「无法区分自有仓库和第三方依赖」的问题，在 vendor 下的是第三方依赖，GOPATH 下的是自有。</p><p>其次，我们要求代码仓库上传的时候把 vendor 带上，虽然这会一定程度使得代码仓库体积更大，但这无非增加点碳排放和代码仓库组同事的工作量罢了，却能很好的解决「手动下载依赖包」带来的诸多问题，这对我们当然是可接受的（代码仓库组同事：你礼貌吗。</p><p>最后，我们允许一个项目中存在多个 vendor 目录，他们位于不同的目录下，影响着不同目录的依赖，此规则的优势或许难以直观地看出，但使用过程中我们会发现它的好处的。这可能有点绕，我们举个例子，我们的项目 repo 依赖 pkg1, pkg2 和 pkg3，他们的目录分别如下：repo&#x2F;module1&#x2F;vendor&#x2F;pkg1，repo&#x2F;module2&#x2F;vendor&#x2F;pkg2，repo&#x2F;vendor&#x2F;pkg3。那么，你在 repo&#x2F;module1&#x2F; 下可以 import pkg1, pkg3，在 repo&#x2F;module2&#x2F; 下可以 import pkg2, pkg3，在 repo&#x2F; 和 repo&#x2F;module3 下则只能 import pkg3。此外，我们还允许在 GOPATH&#x2F;src 下的每一级目录（包括 src）都有 vendor，最终寻找依赖的规则在下文中列出。</p><p>以上，我们解决了一部分问题，至于剩下的问题，让我们相信后人的智慧吧，大家都喜欢这么做，我们自然也可以～</p><p>最终，我们形成了如下的一组规则，这便是 Vendor 机制：</p><ul><li>将依赖包统一放到一个叫 vendor 的目录下，并遵循：<ul><li>可以有多个不同目录下的 vendor，其作用域满足下面的查找规则</li><li>上传项目的时候应该将 vendor 一并传到代码仓库中</li><li>单个 vendor 目录下的包放置目录规则和 GOPATH 一致，就像 vendor 目录是 $GOPATH&#x2F;src 一样</li><li>vendor 目录仅作为依赖包使用</li></ul></li><li>查找规则<ul><li>在遇到 import 语句时（非标准库），首先查找当前包下的 vendor 目录</li><li>向上级目录查找，直到找到 src 下的 vendor 目录</li><li>在 GOROOT 目录下查找</li><li>在 GOPATH 下面查找依赖包</li></ul></li></ul><p>基于上述规则，我们调整项目如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs text">$GOPATH<br>    - bin<br>    - vendor<br>        github.com<br>            - helper8<br>                - pkg10<br>                - pkg11<br>    - src<br>        - github.com<br>            - hyphennn<br>                - proj1 // 下面的层级是你的源代码<br>                    - 其他代码<br>                    - vendor<br>                        - github.com<br>                            - helper1<br>                                - pkg1<br>                                - pkg2<br>                            - helper2<br>                                - pkg3<br>                                - pkg4<br>                        - golang.org<br>                            - helper3<br>                                - pkg4<br>                            - helper4<br>                                - pkg5<br>                                - pkg6<br>                - proj2<br>                    - vendor<br>                        - github.com<br>                            - helper2<br>                                - pkg3<br>                                - pkg4<br>                        - golang.org<br>                            - helper3<br>                                - pkg4<br>            - vendor<br>                - github.com<br>                    - helper5<br>                        - pkg6<br>                        - pkg7<br>        - golang.org<br>            - helper2<br>                -pkg2<br></code></pre></td></tr></table></figure><p>其中的逻辑看起来可能有些绕，这里地方太小，写不下（绝对不是懒</p><p>按照上面说的规则，去理解一下，整体还是非常清晰的。</p><h3 id="版本三-Module-机制"><a href="#版本三-Module-机制" class="headerlink" title="版本三 Module 机制"></a>版本三 Module 机制</h3><p>Vendor 当然有各种缺点，于是 Module 机制出现了，并且良好地运行至今。介绍 Module 的文章太多了，这里就不班门弄斧了～</p><h2 id="govendor"><a href="#govendor" class="headerlink" title="govendor"></a>govendor</h2><p><a href="https://github.com/kardianos/govendor">govendor</a> 是一个应用比较广泛的项目，主要目标是解决「vendor 目录过于占用空间」和「vendor 目录难以管理依赖包版本」的问题，一定程度上成为了 Go 包管理的事实标准。如今此项目已经不再维护了，也不接收任何新的 PR，但仍然不妨碍我们了解一下。</p><p>govendor 的思路有些像 npm，核心是：不再直接管理依赖包文件，而是使用 vendor.json 的文件来记录依赖包的元信息，是的，这个思路和 package.json 甚至 go.mod 都是非常相似的。使用 govendor 后，原来存放诸多依赖包的 vendor 目录下只需要放置一个 vendor.json 文件，由 govendor 提供的命令行工具维护此文件以及基于此文件下载依赖包。下面给出一个元信息的实例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;<br>  &quot;checksumSHA1&quot;: &quot;GcaTbmmzSGqTb2X6qnNtmDyew1Q=&quot;,<br>  &quot;path&quot;: &quot;github.com/pkg/errors&quot;,<br>  &quot;revision&quot;: &quot;a2d6902c6d2a2f194eb3fb474981ab7867c81505&quot;,<br>  &quot;revisionTime&quot;: &quot;2016-06-27T22:23:52Z&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>从此实例中就可以大体明白 govendor 的工作原理了，并不算非常复杂，我想大约也是因此 govendor 才广受欢迎。</p><p>使用 govendor 后，我们项目的目录便可以简化如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs text">$GOPATH<br>    - bin<br>    - vendor<br>        github.com<br>            - vendor.json<br>    - src<br>        - github.com<br>            - hyphennn<br>                - proj1 // 下面的层级是你的源代码<br>                    - 其他代码<br>                    - vendor<br>                        - vendor.json<br>                - proj2<br>                    - vendor<br>                        - vendor.json<br>            - vendor<br>                - vendor.json<br>        - golang.org<br>            - helper2<br>                -pkg2<br></code></pre></td></tr></table></figure><p>govendor 提供如下的命令参数，含义参照一下解释就能大致理清楚：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;sub-command&gt;<br>init     Create the &quot;vendor&quot; folder and the &quot;vendor.json&quot; file.<br>list     List and filter existing dependencies and packages.<br>add      Add packages from $GOPATH.<br>update   Update packages from $GOPATH.<br>remove   Remove packages from the vendor folder.<br>status   Lists any packages missing, out-of-date, or modified locally.<br>fetch    Add new or update vendor folder packages from remote repository.<br>sync     Pull packages into vendor folder from remote repository with revisions<br>               from vendor.json file.<br>migrate  Move packages from a legacy tool to the vendor folder with metadata.<br>get      Like &quot;go get&quot; but copies dependencies into a &quot;vendor&quot; folder.<br>license  List discovered licenses for the given status or import paths.<br>shell    Run a &quot;shell&quot; to make multiple sub-commands more efficient for large<br>             projects.<br><br>go tool commands that are wrapped:<br>  `+&lt;status&gt;` package selection may be used with them<br>fmt, build, install, clean, test, vet, generate, tool<br><br>&lt;status&gt;<br>+local    (l) packages in your project<br>+external (e) referenced packages in GOPATH but not in current project<br>+vendor   (v) packages in the vendor folder<br>+std      (s) packages in the standard library<br><br>+excluded (x) external packages explicitly excluded from vendoring<br>+unused   (u) packages in the vendor folder, but unused<br>+missing  (m) referenced packages but not found<br><br>+program  (p) package is a main package<br><br>+outside  +external +missing<br>+all      +all packages<br></code></pre></td></tr></table></figure><p>不过，govendor 由于已经不再维护了，因此其在 M 系列芯片的 Mac 上不可用，而且也不清楚高版本 Go 的兼容性。</p><p>由于工作项目需要使用 govendor，因此我复制了一份代码，处理了部分兼容性问题，目前在我本地（Mac M2）看起来没啥问题。地址：<a href="https://github.com/hyphennn/govendor">https://github.com/hyphennn/govendor</a> 。但不清楚有没有未知问题。<br>ps. 之所以不 fork，是因为原项目不再维护了，fork 没有任何意义。</p>]]></content>
    
    
    <categories>
      
      <category>tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bazel-Next Generation of Build?</title>
    <link href="/2024/04/22/bazel-1/"/>
    <url>/2024/04/22/bazel-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Bazel-Next-Generation-of-Build"><a href="#Bazel-Next-Generation-of-Build" class="headerlink" title="Bazel: Next Generation of Build?"></a>Bazel: Next Generation of Build?</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Bazel 是 Google 开源的一款与 Make、Maven 和 Gradle 类似的开源构建和测试工具， 它使用人类可读的高级构建语言 Starlark，支持多种语言，可为多个平台构建输出。 Bazel 支持任意大小的构建目标，并支持跨多个代码库和大量用户的大型代码库，是 Google 主推的一种构建工具。</p><h3 id="Bazel-与其他构建工具的区别"><a href="#Bazel-与其他构建工具的区别" class="headerlink" title="Bazel 与其他构建工具的区别"></a>Bazel 与其他构建工具的区别</h3><ul><li>基于任务（task）的构建系统</li></ul><p>在基于任务的构建系统中，基本的工作单元是任务。每个任务都是可以执行任何类型的逻辑的脚本，而任务将其他任务指定为必须在其之前运行的依赖项。目前使用的主要大多数构建系统（例如 Ant、Maven、Gradle）都基于任务。</p><p>基于任务的构建系统往往都会面临一个问题：程序员的权力过大。因为脚本能执行的动作太丰富，构建系统本身完全不知道脚本在做什么，所以它必须在如何规划和执行构建步骤时非常保守，从而导致性能很差。此外，系统也没有办法确认每个脚本的确在做以及正确完成它声称要完成的工作，因此系统往往会变得非常复杂。这就产生了两个问题：难以并发。因为系统无法了解脚本是否并发安全，因此往往采用串行的方案。难以增量构建。</p><ul><li>基于制品（Artifact）的构建工具</li></ul><p>基于制品的构建工具采用了完全不一样的逻辑，在这样的系统中，程序员的权力被大幅缩减，「任务」转为由构建系统制定，程序员可以对任务做有限的配置，但不能决定任务何时执行、如何执行。程序员只能指定「依赖项」和「构建目标」，由构建系统决定如何执行构建。</p><p>具体到 Bazel 来说，Bazel 提供了一系列「rule」，这些 rule 既可以是官方团队维护的又有可以是第三方维护的。程序员在使用 Bazel 时，只需要指定所使用的 rule，构建目标以及依赖项；Bazel 将自动解析依赖关系，并尽可能以最高效率来完成构建。</p><h3 id="Why-Bazel？"><a href="#Why-Bazel？" class="headerlink" title="Why Bazel？"></a>Why Bazel？</h3><ul><li>fast &amp; correct</li><li>高扩展性，多语言支持</li><li>对大仓友好</li><li>限制程序员的权力</li></ul><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当用户告诉 Bazel 要构建某个 Target 的时候，Bazel 会分析这个文件如何构建（构建动作定义为 Action，和其他构建系统的 Task 大同小异），如果 Target 依赖了其他 Target，Bazel 会进一步分析依赖的 Target 又是如何构建生成的，这样一层层分析下去，最终绘制出完整的执行计划。</p><p>这里的 Action 是 Bazel 的核心概念，也是 Bazel 区分于其他构建工具的重要因素：Action 由 Rule 决定，本质上是 Rule 的实例化；而 Rule 不由构建者决定，构建者只能声明使用了某个 Rule。更具体的来说，Rule 是剥离于项目外的，由 Bazel 官方开发，同时对外暴露相关定义，从而允许第三方开发者开发自定义 Rule。</p><img src="/2024/04/22/bazel-1/task.png" class="" title="Bazel 原理"><p>举个🌰，下面是两个 BUILD.Bazel 文件( Bazel 描述文件)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs starlark">// main/BUILD.bazel<br>cc_binary(<br>    name = &quot;hello-world&quot;,<br>    srcs = [&quot;hello-world.cc&quot;],<br>    deps = [<br>        &quot;:hello-greet&quot;,<br>        &quot;//lib:hello-time&quot;<br>    ]<br>)<br><br>cc_library(<br>    name = &quot;hello-greet&quot;,<br>    srcs = [&quot;hello-greet.cc&quot;],<br>    hdrs = [&quot;hello-greet.h&quot;]<br>)<br><br>// lib/BUILD.bazel<br>cc_library(<br>    name = &quot;hello-time&quot;,<br>    srcs = [&quot;hello-time.cc&quot;],<br>    hdrs = [&quot;hello-time.h&quot;],<br>    deps = [<br>        &quot;:sum&quot;<br>        &quot;//proto:example_data&quot;<br>    ],<br>    visibility = [&quot;//main:__pkg__&quot;]<br>)<br><br>cc_library(<br>    name = &quot;sum&quot;,<br>    srcs = [&quot;sum.cpp&quot;],<br>    hdrs = [&quot;sum.h&quot;],<br>)<br></code></pre></td></tr></table></figure><p>最终，Bazel 会生成类似于如下的编译产物：</p><img src="/2024/04/22/bazel-1/process.png" class="" title="编译过程"><h3 id="并行编译"><a href="#并行编译" class="headerlink" title="并行编译"></a>并行编译</h3><p>Bazel 精准的知道每个 Action 依赖哪些文件，这使得没有相互依赖关系的 Action 可以并行执行，而不用担心竞争问题。因此我们可以充分利用多核 CPU 的特性，尽可能提高并发，优化构建效率。</p><h3 id="增量构建"><a href="#增量构建" class="headerlink" title="增量构建"></a>增量构建</h3><p>Bazel 会检测本地文件系统是否保留着上一次构建的 outputs，如果有，此时 Bazel 只需要分析 inputs, commands 和 envs 和上次相比有没有改变，没有改变就直接跳过该 Action 的执行。尽管这个功能很多现代构建工具都支持，但 Bazel 仍有独特的优势：更快，更准。</p><p>这是因为：Bazel 采用了 Client&#x2F;Server 架构，当用户键入 Bazel build 命令时，调用的是 Bazel 的 client 工具，而 client 会拉起 server，并通过 grpc 协议将请求 (buildRequest) 发送给它。由 server 负责配置的加载，ActionGraph 的生成和执行。构建结束后，Server 并不会立即销毁，而 ActionGraph 也会一直保存在内存中。当用户第二次发起构建时，Bazel 会检测工作空间的哪些文件发生了改变，并更新 ActionGraph。如果没有文件改变，就会直接复用上一次的 ActionGraph 进行分析。</p><h3 id="封闭性"><a href="#封闭性" class="headerlink" title="封闭性"></a>封闭性</h3><p>Bazel 将构建分为多个 action，单个 action 被要求是「封闭」的，这意味着：在任何时间、任何场景，相同的 action 总应该获得相同的结果。封闭性是 Bazel 远程缓存与远程执行的基础。通常来说，Bazel 的 rule 会尽最大可能满足封闭性。</p><h2 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h2><p>在上述的架构中，我们发现，既然 Bazel Action 的执行是封闭的，那么它在哪里执行，有谁执行，便不再重要，因此，一个直观的想法便出现了：为什么不能在远程执行构建，本地只需要下载产物即可呢？远程缓存和远程构建便是 bazel 在这方面的实践。</p><h3 id="远程缓存"><a href="#远程缓存" class="headerlink" title="远程缓存"></a>远程缓存</h3><p>因为 Action 满足封闭性，即相同的 Action 信息一定产生相同的结果，因此可以建立 Action 到 ActionResult 的映射。为了便于索引，Bazel 把 Action 信息通过 sha256 哈希算法压缩成摘要 (Digest)，把 Digest 到 ActionResult 的映射存储在云端，就可以实现 Action 的远程缓存。其他用户&#x2F;机器在执行某个 Action 的时候，可以先查询此 Action 是否存在。如果存在，直接复用即可。</p><p>远程缓存的更多信息可以参见：<a href="https://km.sankuai.com/collabpage/2006036512">https://km.sankuai.com/collabpage/2006036512</a></p><h3 id="远程构建"><a href="#远程构建" class="headerlink" title="远程构建"></a>远程构建</h3><p>更进一步的，既然 ActionResult 可以被不同的 Bazel 任务共享，说明 ActionResult 和 Action 在哪里执行并没有关系。因此，Bazel 在构建时，可以把 Action 发送给另一台服务器执行，对方执行完，向 CAS 上传 ActionResult，然后本地再下载。</p><p>远程构建的更多信息可以参见：<a href="https://km.sankuai.com/collabpage/2113624250">https://km.sankuai.com/collabpage/2113624250</a></p><h2 id="挑战-No-Silver-Bullet"><a href="#挑战-No-Silver-Bullet" class="headerlink" title="挑战- No Silver Bullet"></a>挑战- No Silver Bullet</h2><ul><li>封闭性</li></ul><p>毫无疑问，「封闭」是远程执行的生命线，无论是增量构建还是远程执行，但是，想要真正做到封闭性并不容易，尤其是对于 C++ 这类语言，大部分 C++ 项目都对本地缓存存在严格的要求，如 gcc 版本，lib 库等等，这些都是封闭性的天敌。如何提供封闭性更好的 rule，以及解决不封闭带来的诸多问题，始终是 Bazel 的重要挑战。</p><ul><li>远程构建</li></ul><p>远程构建是 Bazel 的核心发展目标之一，如果没有远程构建，Bazel 只是一个优秀的构建工具，但远程构建则使得 Bazel 能够发展为支撑企业级别的大型分布式构建系统。但是，必须承认的是，远程构建仍然还在发展阶段，许多问题仍然有待解决。</p><ul><li>规模</li></ul><p>事实上，Bazel 的优势也存在一定的局限性，因为其最初设计目标是为了解决谷歌内部大仓的构建问题，因此天然倾向于大规模、多语言、多维护人员的大型仓库，为了对大仓友好付出了许多其他方面的代价，尽管对于大仓而言，这些代价相较于得到的优势可接受甚至微不足道，但对于普通仓库而言则未必如此。归根结底，这是规模的问题。</p><blockquote><p>2020年，有 issue 要求在 k8s 项目中移除 Bazel (<a href="https://github.com/kubernetes/kubernetes/issues/88553)%EF%BC%8C%E6%AD%A4">https://github.com/kubernetes/kubernetes/issues/88553)，此</a> issue 在社区引发了热烈的讨论，并且最终在 2021 年宣布通过并合入主分支。总结此 issue，核心原因是：</p><p>k8s 本身是单语言（Go）项目，早期引入 Bazel 的是为了使用构建缓存，但 Go 后续支持了构建缓存，此时 Bazel 对于 k8s 而言几乎没有优势，反而会为了维护 Bazel 和 go-build 两套构建工具付出很大的代价。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大厂祛魅</title>
    <link href="/2024/04/19/career-review/"/>
    <url>/2024/04/19/career-review/</url>
    
    <content type="html"><![CDATA[<h1 id="大厂祛魅"><a href="#大厂祛魅" class="headerlink" title="大厂祛魅"></a>大厂祛魅</h1><p>我给你写个蛋，程序员都在忙着搞程序呢，那有人看这破博客～</p>]]></content>
    
    
    <categories>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go-inline-perf</title>
    <link href="/2024/03/22/go-inline-perf/"/>
    <url>/2024/03/22/go-inline-perf/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go GC 调优思路</title>
    <link href="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/"/>
    <url>/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="面向高性能的-Go-GC-调优思路"><a href="#面向高性能的-Go-GC-调优思路" class="headerlink" title="面向高性能的 Go GC 调优思路"></a>面向高性能的 Go GC 调优思路</h1><h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>最简单的优化思路是别浪费时间优化了，转 Rust，R 门！</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>FG 是一个纯内存计算服务，其特点是：核心数据使用 map 存储，请求到达服务后，查询 map，进行计算并返回。服务拉起时启动一个协程定时从 DB 获取数据刷新此 map。</p><p>计算逻辑已被优化到几乎最佳，当前最大的性能瓶颈是 GC，由于 map 中存储了大量 k-v 对，且 value 是个复杂结构体，会逃逸到堆上，导致堆上存在大量可达的存活对象， GC Pause 较长，平均在几 ms 到几百 ms，且出现过 GC Pause 超过 1s 的极端场景。这带来的后果是：单实例吞吐量降低，时延优化受阻，毛刺多。</p><p>特点：高并发，核心读接口QPS100w+，单实例（16C32G） QPS 5k+，低时延：要求核心读接口 P99&lt;1ms。</p><p>目标：优化 GC，降低 GC Pause</p><p>此方案存在很多针对 FG 服务特性的特化，但是 GC 逃逸、堆栈分析等思路是共通的。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>使用 Pprof，查看火焰图以及堆使用情况，发现问题根源是堆上的大量存活对象，导致了：</p><ul><li>GC 标记阶段，待标记对象多，并行标记的线程占用大量 CPU 资源。</li><li>GC 清理阶段，待清理对象多，STW 时间增长。</li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>将 map 分为读写两个 map，并在完成数据刷新后交换。这意味着任何时刻，内存中都存在一个只读的 map 和一个只写的 map，从而不再需要保障并发安全，因为写是单协程的。</p><p>这么做的另外一个好处是，方便牺牲写 map 的性能，来换取更好的堆分配和更好的读性能。</p><h2 id="堆栈与内联分析"><a href="#堆栈与内联分析" class="headerlink" title="堆栈与内联分析"></a>堆栈与内联分析</h2><ul><li>写场景避免堆分配<ul><li>在写场景，case by case 的分析传值是否会产生堆逃逸，尽可能的减少逃逸到堆上的对象，最直观的方式是：尽可能使用值传递，尽管会产生复制的性能损耗，但是写 map 的性能变差是可接受的；此外，在某些场景下，可以牺牲代码可读性来减少函数调用，如明确不会内联的场景，会在传递值代价很大的情况下，取消函数调用，直接合并到调用函数内。</li></ul></li><li>读场景避免值复制<ul><li>在读场景，策略则和写场景相反，读场景会尽量使用指针传递，降低值复制的代价。不过内联策略则是一致的。</li></ul></li><li>内联优化<ul><li>我们配置了 -gcflag&#x3D;’-l -l’，牺牲二进制文件的大小来换取更多的内联函数，从而减少值在栈上的传递甚至逃逸到堆上。</li></ul></li></ul><h2 id="GC-逃逸"><a href="#GC-逃逸" class="headerlink" title="GC 逃逸"></a>GC 逃逸</h2><p>前述的优化只是在尽可能减少堆上的对象，但此服务的对象多数都来自 map 中的数十万的 k-v 对，因此最大的瓶颈是如何优化 map。</p><p>很显然，这两个 map 以及其中的对象大部分都是长期不变的，之前见过另外一个 Java 服务有类似场景，他们的思路是通过 UNSAFE 修改对象头，在初始化对象的时候直接将其存活代数改为 15，从而不需要经过 ygc 直接分配到老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateObjAge</span><span class="hljs-params">(Object obj, <span class="hljs-type">int</span> age)</span> &#123; <br>  <span class="hljs-keyword">if</span>(!toUpdateAgeReady || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span>; <br>  &#125;<br><br>  <span class="hljs-type">Long</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> UNSAFE.getLong(obj, <span class="hljs-number">0L</span>);<br>  <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mark &amp; AGE_64_MASK | ((<span class="hljs-type">long</span>)(age &amp; <span class="hljs-number">0xF</span>)) &lt;&lt; <span class="hljs-number">3</span>;<br><br>  UNSAFE.putLong(obj, <span class="hljs-number">0L</span>, result); <br>&#125;<br></code></pre></td></tr></table></figure><p>然而 Go 没有分代 GC，但一个类似的思路是：能否让这些对象对 Runtime 不可见，从而避开 GC？虽然可能会内存泄露，但是只要手动管理好这些内存，收益会是很可观的。</p><p>基于此，我们的想法便很清晰了：如何在 Go 中做到 GC 逃逸？Arena 似乎可行，但它现在还是实验特性，并且 Proposal 被无限期搁置了。但 Arena 的思想我们可以偷一下，于是便有了这个思路。</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>在服务拉起时，绕开语言 API，使用内核 API sys_mmap 直接向 OS 申请内存，自行管理此内存。</p><p>优势：这一片内存是根对象不可达的，Go Runtime 检测不到这一片内存，标记和清理压力会大幅降低。</p><p>劣势：需要手动管理内存。</p><h3 id="gcescape"><a href="#gcescape" class="headerlink" title="gcescape"></a>gcescape</h3><p><a href="https://github.com/hyphennn/gcescape">https://github.com/hyphennn/gcescape</a></p><p>广告时间：强烈推荐，一个超快的 go collection 库，可以帮助你超大幅度的降低 gc 时间，超过 99%！</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>弃用标准库 map，自行实现 GCEscapeMap，使用 GCEscapeMap 作为核心数据的存储。</p><p>核心数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> GCEscapeMap[T any] <span class="hljs-keyword">struct</span> &#123;<br>s       []T<br>realCap <span class="hljs-type">int</span><br>realLen <span class="hljs-type">int</span><br>idxMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>核心方法：向内核申请内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeSlice</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(<span class="hljs-built_in">len</span> <span class="hljs-type">int</span>)</span></span> reflect.SliceHeader &#123;<br>fd := <span class="hljs-number">-1</span><br><span class="hljs-keyword">var</span> t T<br>data, _, errno := syscall.Syscall6(<br>syscall.SYS_MMAP,<br><span class="hljs-number">0</span>, <span class="hljs-comment">// address</span><br><span class="hljs-type">uintptr</span>(<span class="hljs-built_in">len</span>)*unsafe.Sizeof(t),<br>syscall.PROT_READ|syscall.PROT_WRITE,<br>syscall.MAP_ANON|syscall.MAP_PRIVATE,<br><span class="hljs-type">uintptr</span>(fd), <span class="hljs-comment">// No file descriptor</span><br><span class="hljs-number">0</span>,           <span class="hljs-comment">// offset</span><br>)<br><span class="hljs-keyword">if</span> errno != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(errno)<br>&#125;<br><br><span class="hljs-keyword">return</span> reflect.SliceHeader&#123;<br>Data: data,<br>Len:  <span class="hljs-built_in">len</span>,<br>Cap:  <span class="hljs-built_in">len</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于申请的内存初始化 GCEscapeMap</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 初始化 GCEscapeMap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGCEscapeMap</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(<span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> *GCEscapeMap[T] &#123;<br><span class="hljs-keyword">var</span> t T<br><span class="hljs-keyword">if</span> reflect.TypeOf(t).Kind() == reflect.Pointer &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;no ptr allowed&quot;</span>)<br>&#125;<br>data := makeSlice[T](<span class="hljs-built_in">cap</span>)<br>s := *(*[]T)(unsafe.Pointer(&amp;data))<br><span class="hljs-keyword">return</span> &amp;GCEscapeMap[T]&#123;s: s, realCap: <span class="hljs-built_in">cap</span>, realLen: <span class="hljs-number">0</span>, idxMap: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">cap</span>)&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读&amp;写 map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *GCEscapeMap[T])</span></span> Push(k <span class="hljs-type">int</span>, v T) &#123;<br>idx, ok := e.idxMap[k]<br><span class="hljs-keyword">if</span> ok &#123;<br>e.s[idx] = v<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>e.s[e.realLen] = v<br>e.realLen++<br>e.CheckAndScale()<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *GCEscapeMap[T])</span></span> Get(k <span class="hljs-type">int</span>) (*T, <span class="hljs-type">bool</span>) &#123;<br>idx, ok := e.idxMap[k]<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">return</span> &amp;e.s[idx], <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>e.CheckAndScale(): 此方法用于检测 realLen 和 realCap 的比值，在超过「安全阈值」时会开始告警，在超过「扩容阈值」时会开始主动扩容并告警，其原理和 Slice 一致，如果主动扩容失败，将中止读写 map 交换并告警。其中会存在大量业务和告警代码，因此不写了。 </p><p>需要指出的是，主动扩容是非常危险、代价非常高的操作，因此我们需要尽可能避免其出现：关注实例内存用量；关注 GCEscapeMap 当前用量。</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>GCEscapeMap 包含以下成员：</p><ul><li>s 是数据真实存储的位置，由于其是直接向 OS 申请的，因此不会被 Runtime 扫描到。</li><li>realCap 和 realLen 用于控制 s 来实现类似 slice 的功能，因为 s 实际是定长的。</li><li>idxMap 是用于实现 map 能力的，其 k,v 都是 int，因此会被 Runtime 忽略（Go 1.5 开始提供此特性：<a href="https://go-review.googlesource.com/c/go/+/3288%EF%BC%89">https://go-review.googlesource.com/c/go/+/3288）</a></li></ul><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>我们使用 benchmark 来检验性能，并使用 Pprof 来观察堆情况</p><p>benchmark：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkEmap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>m := emap.NewGCEscapeMap(<span class="hljs-number">2000000</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>m.Push(i, TestAim&#123;<br>Str:    <span class="hljs-string">&quot;1&quot;</span>,<br>Map:    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;,<br>Value:  <span class="hljs-number">0</span>,<br>Str2:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str3:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str4:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str5:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str6:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str7:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str8:   <span class="hljs-string">&quot;1&quot;</span>,<br>Value2: <span class="hljs-number">0</span>,<br>Value3: <span class="hljs-number">0</span>,<br>Value4: <span class="hljs-number">0</span>,<br>Value5: <span class="hljs-number">0</span>,<br>Value6: <span class="hljs-number">0</span>,<br>Value7: <span class="hljs-number">0</span>,<br>&#125;)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>m.Get(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkNormalMap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]emap.Aim, <span class="hljs-number">1000000</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>m[i] = TestAim&#123;<br>Str:    <span class="hljs-string">&quot;1&quot;</span>,<br>Map:    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;,<br>Value:  <span class="hljs-number">0</span>,<br>Str2:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str3:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str4:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str5:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str6:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str7:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str8:   <span class="hljs-string">&quot;1&quot;</span>,<br>Value2: <span class="hljs-number">0</span>,<br>Value3: <span class="hljs-number">0</span>,<br>Value4: <span class="hljs-number">0</span>,<br>Value5: <span class="hljs-number">0</span>,<br>Value6: <span class="hljs-number">0</span>,<br>Value7: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>_ = m[i]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/img.png" class="" title="Benchmark 结果"><p>Pprof</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;()<br>time.Sleep(time.Second)<br>UseGCEscapeMap()<br><span class="hljs-comment">//UseNormalMap()</span><br>time.Sleep(<span class="hljs-number">1000</span> * time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UseGCEscapeMap</span><span class="hljs-params">()</span></span> &#123;<br>m := emap.NewGCEscapeMap[TestAim](<span class="hljs-number">2000000</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>m.Push(i, TestAim&#123;<br>Str:    <span class="hljs-string">&quot;1&quot;</span>,<br>Map:    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;,<br>Value:  <span class="hljs-number">0</span>,<br>Str2:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str3:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str4:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str5:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str6:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str7:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str8:   <span class="hljs-string">&quot;1&quot;</span>,<br>Value2: <span class="hljs-number">0</span>,<br>Value3: <span class="hljs-number">0</span>,<br>Value4: <span class="hljs-number">0</span>,<br>Value5: <span class="hljs-number">0</span>,<br>Value6: <span class="hljs-number">0</span>,<br>Value7: <span class="hljs-number">0</span>,<br>&#125;)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>st := time.Now()<br>runtime.GC()<br>fmt.Printf(<span class="hljs-string">&quot;GC took %s\n&quot;</span>, time.Since(st))<br>time.Sleep(time.Second)<br>&#125;<br><br>runtime.KeepAlive(m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UseNormalMap</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]TestAim, <span class="hljs-number">1000000</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>m[i] = TestAim&#123;<br>Str:    <span class="hljs-string">&quot;1&quot;</span>,<br>Map:    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;,<br>Value:  <span class="hljs-number">0</span>,<br>Str2:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str3:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str4:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str5:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str6:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str7:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str8:   <span class="hljs-string">&quot;1&quot;</span>,<br>Value2: <span class="hljs-number">0</span>,<br>Value3: <span class="hljs-number">0</span>,<br>Value4: <span class="hljs-number">0</span>,<br>Value5: <span class="hljs-number">0</span>,<br>Value6: <span class="hljs-number">0</span>,<br>Value7: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>st := time.Now()<br>runtime.GC()<br>fmt.Printf(<span class="hljs-string">&quot;GC took %s\n&quot;</span>, time.Since(st))<br>time.Sleep(time.Second)<br>&#125;<br><br>runtime.KeepAlive(m)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>UseGCEscapeMap：</p><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/stdout-em.png" class="" title="UseGCEscapeMap输出结果"><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/heap-status-em.png" class="" title="UseGCEscapeMap堆状态"><p>UseNormalMap:</p><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/stdout-nm.png" class="" title="UseNormalMap输出结果"><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/heap-status-nm.png" class="" title="UseNormalMap堆状态">]]></content>
    
    
    <categories>
      
      <category>tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>End&amp;Start</title>
    <link href="/2024/02/23/End-Start/"/>
    <url>/2024/02/23/End-Start/</url>
    
    <content type="html"><![CDATA[<h1 id="End-Start"><a href="#End-Start" class="headerlink" title="End&amp;Start"></a>End&amp;Start</h1><p>立个 flag：这个周末写点东西～</p>]]></content>
    
    
    <categories>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hello-world</title>
    <link href="/2024/01/25/hello-world/"/>
    <url>/2024/01/25/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hyphen"><a href="#Hyphen" class="headerlink" title="Hyphen"></a>Hyphen</h1><p>This is a Hello World page</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello Wolrd!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Only For Hyphen</title>
    <link href="/2018/06/08/i-am-not-hyphen/"/>
    <url>/2018/06/08/i-am-not-hyphen/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5c427d07944d07618e7b8b3c26cef0aaba2e437ba6a4a291fac82573d0e9ad68">e32ff89d1b75ae8a97b4d649089b0415557849d44d6f7d9231c9cc419469499601104b083f3a91f72e88953950b3141825bc920cec6696baf4593bc2223f194b34f8496faa8a51f00931dbff76707d008c7a79a758b2c3a35cfa37d3b356b095e88f74ae58394bfba61c32f126a1af44281bddee701fe9b97eba181cb84019cdd3e77b826f22d921a1466936089f99ce835d8aa682ff411ac47948d71d0973bf74c7bec24334b492c4a53850d0db1c62b4059b2785fa300cb82c8b00796588a4cf7d52848a1a29e20e833c171ea628c25c1c05d11749c08dac204b975b47d5f8c77e900313abd3b18b39ea92dc55b4ff6830ede0a61dc2ad9b7fbceac42b1de6524c3ceaefb0ea9bca3441e316880b66a2ef45635054e103c2f9cf3a9d6d965c5128a62b9867e60dc70d320361aa06494c9e08b850ccd94864aef112afc00f474f6fef8ffdead71c20b93641abe3178eee04bfa2dd3e1215f4c0a70fc3f9f3e40585694523915d4a03cefa0d7c1ff21da1938dda865090eeacb07197b58199ddbf7fadf6f5f46b5c14a88ece793df59555b9bd2238941765ff4a60a8548715bc287dc2fb4443b9be3cf3face5eefdfd8d1b216899c423e5889bd2da3c34f10c0e1e71c666c6f8d99efb4bd83454db7a1b30b41afa0cb03274a73be11946a61c7cb1a5cbcb2afd608655691585bff0a1b73aea523e740750fd52362f437ddec3aeb88e2769857df662f04df6aec75bcefc4011dba9de39890659d5356af2f136083588607894187f99ebbe982a8bd1b34dfab6c512f99b111cbab8b3d87e0212d30826e931bc660639aa12ade00e7679d0452669c2168eaa72cbbc6c434ac8475c3c6b9116cbe7c7cb87001342a5b244777f8e92ca160256b23306014676aea2c1625a925eb5d441fbbf42e56015ec69ee1d6d687605c5d27a2b23782ae2a58388b66e98275303517ee5aee2c232875e47a89fb8319a4888dda79020bd259722529bf841fe18497b4cd9750bc62f54f23f6f51d6374bc4b7383aba231f3daf74a9574353f8701fc8233712c1c9308650d347ac3b7e96d72f018d7e643ffc1c48d66d62bc4eea686a6b2bc39dd2d74766a5fe83ed323a4a9e9e8edcb623ce3328aa97b8d819e4a152725a9cf02106c70861ecffc9849fab923fa1c41549ccd9ca914fb4b28ceb9fe0355df019ada09ef0407fdc24db9448b534777b376c31b6b1ff50ba5b925a8db45b21daac95c5d2f9b8fa3c43a84fcdd4fe6d52ca6f577b9df8b387317c5d9a7547fcddf48b7719a7db15194125b0f65663319db54f65867a96dd704817546da4e409e2a60ad1dbc8e40d1a1881e956b103e691465856119674cf2c0ea1e4e13141218458b423ebab4a4e8d63fe4c7a98c592867d12b9cfd84722885cf0615ff2328a6779a1b76d1a09a147c0c38a2b29f170c32f1bbe2afc951e9334232776e7ec142bf060fc4b3d7cfc3bb333abb1dba4aed8bb917bbd48ee6ca6d2344a152746c94ab0b1564275ff734e76e1fe9a4674933f2c08a613092ee660b3ea6d03f107d05b173fd50d967a42dea7c2c9c0067ef5e98e2d58387fdb19b540c654f34f57487d8eb69e507b79ce36cdf8c6b5a6d52c14facf84cf8cfc811ca3a0062ce2e8eaba251aa032676552c2c1c51fc2035b67d3e68fdf59972244ebb8fb1e0c85f6cbc574bd15e58fdcd9764498fc687c3e7de585151d408c55c7829d01ccad4d91e32b520aaca0e7654912fd8b1b7982ab32b0a01a904794b01d5da6cbef15b418a4f9fbbc45f7992b6eaae654feb2772bd7e3183f00032414871101f1f42dbc97370fc61168727cda57379e5c6e6b2dd78f137a462ce54e22797661222d2e9e8bb6d39686a900a0d08b728432e15f7ecf8a954f53ba4841b95820aad2a224beae55ed9c74fe391a76e5a204b35aa814b13d4e4ed9b6d55c889bb4649836ccfda9a2cca9df55244b8b350b89dd3074b787df464b3315c363fbd474365816376d02ab9838687a5e423</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="wobuguan">wobuguan</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>self</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
