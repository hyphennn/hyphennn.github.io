<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Bazel-Next Generation of Build?</title>
    <link href="/2024/04/22/bazel-1/"/>
    <url>/2024/04/22/bazel-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Bazel-Next-Generation-of-Build"><a href="#Bazel-Next-Generation-of-Build" class="headerlink" title="Bazel: Next Generation of Build?"></a>Bazel: Next Generation of Build?</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Bazel 是 Google 开源的一款与 Make、Maven 和 Gradle 类似的开源构建和测试工具， 它使用人类可读的高级构建语言 Starlark，支持多种语言，可为多个平台构建输出。 Bazel 支持任意大小的构建目标，并支持跨多个代码库和大量用户的大型代码库，是 Google 主推的一种构建工具。</p><h3 id="Bazel-与其他构建工具的区别"><a href="#Bazel-与其他构建工具的区别" class="headerlink" title="Bazel 与其他构建工具的区别"></a>Bazel 与其他构建工具的区别</h3><ul><li>基于任务（task）的构建系统</li></ul><p>在基于任务的构建系统中，基本的工作单元是任务。每个任务都是可以执行任何类型的逻辑的脚本，而任务将其他任务指定为必须在其之前运行的依赖项。目前使用的主要大多数构建系统（例如 Ant、Maven、Gradle）都基于任务。</p><p>基于任务的构建系统往往都会面临一个问题：程序员的权力过大。因为脚本能执行的动作太丰富，构建系统本身完全不知道脚本在做什么，所以它必须在如何规划和执行构建步骤时非常保守，从而导致性能很差。此外，系统也没有办法确认每个脚本的确在做以及正确完成它声称要完成的工作，因此系统往往会变得非常复杂。这就产生了两个问题：难以并发。因为系统无法了解脚本是否并发安全，因此往往采用串行的方案。难以增量构建。</p><ul><li>基于制品（Artifact）的构建工具</li></ul><p>基于制品的构建工具采用了完全不一样的逻辑，在这样的系统中，程序员的权力被大幅缩减，「任务」转为由构建系统制定，程序员可以对任务做有限的配置，但不能决定任务何时执行、如何执行。程序员只能指定「依赖项」和「构建目标」，由构建系统决定如何执行构建。</p><p>具体到 Bazel 来说，Bazel 提供了一系列「rule」，这些 rule 既可以是官方团队维护的又有可以是第三方维护的。程序员在使用 Bazel 时，只需要指定所使用的 rule，构建目标以及依赖项；Bazel 将自动解析依赖关系，并尽可能以最高效率来完成构建。</p><h3 id="Why-Bazel？"><a href="#Why-Bazel？" class="headerlink" title="Why Bazel？"></a>Why Bazel？</h3><ul><li>fast &amp; correct</li><li>高扩展性，多语言支持</li><li>对大仓友好</li><li>限制程序员的权力</li></ul><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当用户告诉 Bazel 要构建某个 Target 的时候，Bazel 会分析这个文件如何构建（构建动作定义为 Action，和其他构建系统的 Task 大同小异），如果 Target 依赖了其他 Target，Bazel 会进一步分析依赖的 Target 又是如何构建生成的，这样一层层分析下去，最终绘制出完整的执行计划。</p><p>这里的 Action 是 Bazel 的核心概念，也是 Bazel 区分于其他构建工具的重要因素：Action 由 Rule 决定，本质上是 Rule 的实例化；而 Rule 不由构建者决定，构建者只能声明使用了某个 Rule。更具体的来说，Rule 是剥离于项目外的，由 Bazel 官方开发，同时对外暴露相关定义，从而允许第三方开发者开发自定义 Rule。</p><img src="/2024/04/22/bazel-1/task.png" class="" title="Bazel 原理"><p>举个🌰，下面是两个 BUILD.Bazel 文件( Bazel 描述文件)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs starlark">// main/BUILD.bazel<br>cc_binary(<br>    name = &quot;hello-world&quot;,<br>    srcs = [&quot;hello-world.cc&quot;],<br>    deps = [<br>        &quot;:hello-greet&quot;,<br>        &quot;//lib:hello-time&quot;<br>    ]<br>)<br><br>cc_library(<br>    name = &quot;hello-greet&quot;,<br>    srcs = [&quot;hello-greet.cc&quot;],<br>    hdrs = [&quot;hello-greet.h&quot;]<br>)<br><br>// lib/BUILD.bazel<br>cc_library(<br>    name = &quot;hello-time&quot;,<br>    srcs = [&quot;hello-time.cc&quot;],<br>    hdrs = [&quot;hello-time.h&quot;],<br>    deps = [<br>        &quot;:sum&quot;<br>        &quot;//proto:example_data&quot;<br>    ],<br>    visibility = [&quot;//main:__pkg__&quot;]<br>)<br><br>cc_library(<br>    name = &quot;sum&quot;,<br>    srcs = [&quot;sum.cpp&quot;],<br>    hdrs = [&quot;sum.h&quot;],<br>)<br></code></pre></td></tr></table></figure><p>最终，Bazel 会生成类似于如下的编译产物：</p><img src="/2024/04/22/bazel-1/process.png" class="" title="编译过程"><h3 id="并行编译"><a href="#并行编译" class="headerlink" title="并行编译"></a>并行编译</h3><p>Bazel 精准的知道每个 Action 依赖哪些文件，这使得没有相互依赖关系的 Action 可以并行执行，而不用担心竞争问题。因此我们可以充分利用多核 CPU 的特性，尽可能提高并发，优化构建效率。</p><h3 id="增量构建"><a href="#增量构建" class="headerlink" title="增量构建"></a>增量构建</h3><p>Bazel 会检测本地文件系统是否保留着上一次构建的 outputs，如果有，此时 Bazel 只需要分析 inputs, commands 和 envs 和上次相比有没有改变，没有改变就直接跳过该 Action 的执行。尽管这个功能很多现代构建工具都支持，但 Bazel 仍有独特的优势：更快，更准。</p><p>这是因为：Bazel 采用了 Client&#x2F;Server 架构，当用户键入 Bazel build 命令时，调用的是 Bazel 的 client 工具，而 client 会拉起 server，并通过 grpc 协议将请求 (buildRequest) 发送给它。由 server 负责配置的加载，ActionGraph 的生成和执行。构建结束后，Server 并不会立即销毁，而 ActionGraph 也会一直保存在内存中。当用户第二次发起构建时，Bazel 会检测工作空间的哪些文件发生了改变，并更新 ActionGraph。如果没有文件改变，就会直接复用上一次的 ActionGraph 进行分析。</p><h3 id="封闭性"><a href="#封闭性" class="headerlink" title="封闭性"></a>封闭性</h3><p>Bazel 将构建分为多个 action，单个 action 被要求是「封闭」的，这意味着：在任何时间、任何场景，相同的 action 总应该获得相同的结果。封闭性是 Bazel 远程缓存与远程执行的基础。通常来说，Bazel 的 rule 会尽最大可能满足封闭性。</p><h2 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h2><p>在上述的架构中，我们发现，既然 Bazel Action 的执行是封闭的，那么它在哪里执行，有谁执行，便不再重要，因此，一个直观的想法便出现了：为什么不能在远程执行构建，本地只需要下载产物即可呢？远程缓存和远程构建便是 bazel 在这方面的实践。</p><h3 id="远程缓存"><a href="#远程缓存" class="headerlink" title="远程缓存"></a>远程缓存</h3><p>因为 Action 满足封闭性，即相同的 Action 信息一定产生相同的结果，因此可以建立 Action 到 ActionResult 的映射。为了便于索引，Bazel 把 Action 信息通过 sha256 哈希算法压缩成摘要 (Digest)，把 Digest 到 ActionResult 的映射存储在云端，就可以实现 Action 的远程缓存。其他用户&#x2F;机器在执行某个 Action 的时候，可以先查询此 Action 是否存在。如果存在，直接复用即可。</p><p>远程缓存的更多信息可以参见：<a href="https://km.sankuai.com/collabpage/2006036512">https://km.sankuai.com/collabpage/2006036512</a></p><h3 id="远程构建"><a href="#远程构建" class="headerlink" title="远程构建"></a>远程构建</h3><p>更进一步的，既然 ActionResult 可以被不同的 Bazel 任务共享，说明 ActionResult 和 Action 在哪里执行并没有关系。因此，Bazel 在构建时，可以把 Action 发送给另一台服务器执行，对方执行完，向 CAS 上传 ActionResult，然后本地再下载。</p><p>远程构建的更多信息可以参见：<a href="https://km.sankuai.com/collabpage/2113624250">https://km.sankuai.com/collabpage/2113624250</a></p><h2 id="挑战-No-Silver-Bullet"><a href="#挑战-No-Silver-Bullet" class="headerlink" title="挑战- No Silver Bullet"></a>挑战- No Silver Bullet</h2><ul><li>封闭性</li></ul><p>毫无疑问，「封闭」是远程执行的生命线，无论是增量构建还是远程执行，但是，想要真正做到封闭性并不容易，尤其是对于 C++ 这类语言，大部分 C++ 项目都对本地缓存存在严格的要求，如 gcc 版本，lib 库等等，这些都是封闭性的天敌。如何提供封闭性更好的 rule，以及解决不封闭带来的诸多问题，始终是 Bazel 的重要挑战。</p><ul><li>远程构建</li></ul><p>远程构建是 Bazel 的核心发展目标之一，如果没有远程构建，Bazel 只是一个优秀的构建工具，但远程构建则使得 Bazel 能够发展为支撑企业级别的大型分布式构建系统。但是，必须承认的是，远程构建仍然还在发展阶段，许多问题仍然有待解决。</p><ul><li>规模</li></ul><p>事实上，Bazel 的优势也存在一定的局限性，因为其最初设计目标是为了解决谷歌内部大仓的构建问题，因此天然倾向于大规模、多语言、多维护人员的大型仓库，为了对大仓友好付出了许多其他方面的代价，尽管对于大仓而言，这些代价相较于得到的优势可接受甚至微不足道，但对于普通仓库而言则未必如此。归根结底，这是规模的问题。</p><blockquote><p>2020年，有 issue 要求在 k8s 项目中移除 Bazel (<a href="https://github.com/kubernetes/kubernetes/issues/88553)%EF%BC%8C%E6%AD%A4">https://github.com/kubernetes/kubernetes/issues/88553)，此</a> issue 在社区引发了热烈的讨论，并且最终在 2021 年宣布通过并合入主分支。总结此 issue，核心原因是：</p><p>k8s 本身是单语言（Go）项目，早期引入 Bazel 的是为了使用构建缓存，但 Go 后续支持了构建缓存，此时 Bazel 对于 k8s 而言几乎没有优势，反而会为了维护 Bazel 和 go-build 两套构建工具付出很大的代价。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大厂祛魅</title>
    <link href="/2024/04/19/career-review/"/>
    <url>/2024/04/19/career-review/</url>
    
    <content type="html"><![CDATA[<h1 id="大厂祛魅"><a href="#大厂祛魅" class="headerlink" title="大厂祛魅"></a>大厂祛魅</h1><p>我给你写个蛋，程序员都在忙着搞程序呢，那有人看这破博客～</p>]]></content>
    
    
    <categories>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go-inline-perf</title>
    <link href="/2024/03/22/go-inline-perf/"/>
    <url>/2024/03/22/go-inline-perf/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go GC 调优思路</title>
    <link href="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/"/>
    <url>/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="面向高性能的-Go-GC-调优思路"><a href="#面向高性能的-Go-GC-调优思路" class="headerlink" title="面向高性能的 Go GC 调优思路"></a>面向高性能的 Go GC 调优思路</h1><h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>最简单的优化思路是别浪费时间优化了，转 Rust，R 门！</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>FG 是一个纯内存计算服务，其特点是：核心数据使用 map 存储，请求到达服务后，查询 map，进行计算并返回。服务拉起时启动一个协程定时从 DB 获取数据刷新此 map。</p><p>计算逻辑已被优化到几乎最佳，当前最大的性能瓶颈是 GC，由于 map 中存储了大量 k-v 对，且 value 是个复杂结构体，会逃逸到堆上，导致堆上存在大量可达的存活对象， GC Pause 较长，平均在几 ms 到几百 ms，且出现过 GC Pause 超过 1s 的极端场景。这带来的后果是：单实例吞吐量降低，时延优化受阻，毛刺多。</p><p>特点：高并发，核心读接口QPS100w+，单实例（16C32G） QPS 5k+，低时延：要求核心读接口 P99&lt;1ms。</p><p>目标：优化 GC，降低 GC Pause</p><p>此方案存在很多针对 FG 服务特性的特化，但是 GC 逃逸、堆栈分析等思路是共通的。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>使用 Pprof，查看火焰图以及堆使用情况，发现问题根源是堆上的大量存活对象，导致了：</p><ul><li>GC 标记阶段，待标记对象多，并行标记的线程占用大量 CPU 资源。</li><li>GC 清理阶段，待清理对象多，STW 时间增长。</li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>将 map 分为读写两个 map，并在完成数据刷新后交换。这意味着任何时刻，内存中都存在一个只读的 map 和一个只写的 map，从而不再需要保障并发安全，因为写是单协程的。</p><p>这么做的另外一个好处是，方便牺牲写 map 的性能，来换取更好的堆分配和更好的读性能。</p><h2 id="堆栈与内联分析"><a href="#堆栈与内联分析" class="headerlink" title="堆栈与内联分析"></a>堆栈与内联分析</h2><ul><li>写场景避免堆分配<ul><li>在写场景，case by case 的分析传值是否会产生堆逃逸，尽可能的减少逃逸到堆上的对象，最直观的方式是：尽可能使用值传递，尽管会产生复制的性能损耗，但是写 map 的性能变差是可接受的；此外，在某些场景下，可以牺牲代码可读性来减少函数调用，如明确不会内联的场景，会在传递值代价很大的情况下，取消函数调用，直接合并到调用函数内。</li></ul></li><li>读场景避免值复制<ul><li>在读场景，策略则和写场景相反，读场景会尽量使用指针传递，降低值复制的代价。不过内联策略则是一致的。</li></ul></li><li>内联优化<ul><li>我们配置了 -gcflag&#x3D;’-l -l’，牺牲二进制文件的大小来换取更多的内联函数，从而减少值在栈上的传递甚至逃逸到堆上。</li></ul></li></ul><h2 id="GC-逃逸"><a href="#GC-逃逸" class="headerlink" title="GC 逃逸"></a>GC 逃逸</h2><p>前述的优化只是在尽可能减少堆上的对象，但此服务的对象多数都来自 map 中的数十万的 k-v 对，因此最大的瓶颈是如何优化 map。</p><p>很显然，这两个 map 以及其中的对象大部分都是长期不变的，之前见过另外一个 Java 服务有类似场景，他们的思路是通过 UNSAFE 修改对象头，在初始化对象的时候直接将其存活代数改为 15，从而不需要经过 ygc 直接分配到老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateObjAge</span><span class="hljs-params">(Object obj, <span class="hljs-type">int</span> age)</span> &#123; <br>  <span class="hljs-keyword">if</span>(!toUpdateAgeReady || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span>; <br>  &#125;<br><br>  <span class="hljs-type">Long</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> UNSAFE.getLong(obj, <span class="hljs-number">0L</span>);<br>  <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mark &amp; AGE_64_MASK | ((<span class="hljs-type">long</span>)(age &amp; <span class="hljs-number">0xF</span>)) &lt;&lt; <span class="hljs-number">3</span>;<br><br>  UNSAFE.putLong(obj, <span class="hljs-number">0L</span>, result); <br>&#125;<br></code></pre></td></tr></table></figure><p>然而 Go 没有分代 GC，但一个类似的思路是：能否让这些对象对 Runtime 不可见，从而避开 GC？虽然可能会内存泄露，但是只要手动管理好这些内存，收益会是很可观的。</p><p>基于此，我们的想法便很清晰了：如何在 Go 中做到 GC 逃逸？Arena 似乎可行，但它现在还是实验特性，并且 Proposal 被无限期搁置了。但 Arena 的思想我们可以偷一下，于是便有了这个思路。</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>在服务拉起时，绕开语言 API，使用内核 API sys_mmap 直接向 OS 申请内存，自行管理此内存。</p><p>优势：这一片内存是根对象不可达的，Go Runtime 检测不到这一片内存，标记和清理压力会大幅降低。</p><p>劣势：需要手动管理内存。</p><h3 id="gcescape"><a href="#gcescape" class="headerlink" title="gcescape"></a>gcescape</h3><p><a href="https://github.com/hyphennn/gcescape">https://github.com/hyphennn/gcescape</a></p><p>广告时间：强烈推荐，一个超快的 go collection 库，可以帮助你超大幅度的降低 gc 时间，超过 99%！</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>弃用标准库 map，自行实现 GCEscapeMap，使用 GCEscapeMap 作为核心数据的存储。</p><p>核心数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> GCEscapeMap[T any] <span class="hljs-keyword">struct</span> &#123;<br>s       []T<br>realCap <span class="hljs-type">int</span><br>realLen <span class="hljs-type">int</span><br>idxMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>核心方法：向内核申请内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeSlice</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(<span class="hljs-built_in">len</span> <span class="hljs-type">int</span>)</span></span> reflect.SliceHeader &#123;<br>fd := <span class="hljs-number">-1</span><br><span class="hljs-keyword">var</span> t T<br>data, _, errno := syscall.Syscall6(<br>syscall.SYS_MMAP,<br><span class="hljs-number">0</span>, <span class="hljs-comment">// address</span><br><span class="hljs-type">uintptr</span>(<span class="hljs-built_in">len</span>)*unsafe.Sizeof(t),<br>syscall.PROT_READ|syscall.PROT_WRITE,<br>syscall.MAP_ANON|syscall.MAP_PRIVATE,<br><span class="hljs-type">uintptr</span>(fd), <span class="hljs-comment">// No file descriptor</span><br><span class="hljs-number">0</span>,           <span class="hljs-comment">// offset</span><br>)<br><span class="hljs-keyword">if</span> errno != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(errno)<br>&#125;<br><br><span class="hljs-keyword">return</span> reflect.SliceHeader&#123;<br>Data: data,<br>Len:  <span class="hljs-built_in">len</span>,<br>Cap:  <span class="hljs-built_in">len</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于申请的内存初始化 GCEscapeMap</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 初始化 GCEscapeMap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGCEscapeMap</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(<span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> *GCEscapeMap[T] &#123;<br><span class="hljs-keyword">var</span> t T<br><span class="hljs-keyword">if</span> reflect.TypeOf(t).Kind() == reflect.Pointer &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;no ptr allowed&quot;</span>)<br>&#125;<br>data := makeSlice[T](<span class="hljs-built_in">cap</span>)<br>s := *(*[]T)(unsafe.Pointer(&amp;data))<br><span class="hljs-keyword">return</span> &amp;GCEscapeMap[T]&#123;s: s, realCap: <span class="hljs-built_in">cap</span>, realLen: <span class="hljs-number">0</span>, idxMap: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">cap</span>)&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读&amp;写 map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *GCEscapeMap[T])</span></span> Push(k <span class="hljs-type">int</span>, v T) &#123;<br>idx, ok := e.idxMap[k]<br><span class="hljs-keyword">if</span> ok &#123;<br>e.s[idx] = v<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>e.s[e.realLen] = v<br>e.realLen++<br>e.CheckAndScale()<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *GCEscapeMap[T])</span></span> Get(k <span class="hljs-type">int</span>) (*T, <span class="hljs-type">bool</span>) &#123;<br>idx, ok := e.idxMap[k]<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">return</span> &amp;e.s[idx], <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>e.CheckAndScale(): 此方法用于检测 realLen 和 realCap 的比值，在超过「安全阈值」时会开始告警，在超过「扩容阈值」时会开始主动扩容并告警，其原理和 Slice 一致，如果主动扩容失败，将中止读写 map 交换并告警。其中会存在大量业务和告警代码，因此不写了。 </p><p>需要指出的是，主动扩容是非常危险、代价非常高的操作，因此我们需要尽可能避免其出现：关注实例内存用量；关注 GCEscapeMap 当前用量。</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>GCEscapeMap 包含以下成员：</p><ul><li>s 是数据真实存储的位置，由于其是直接向 OS 申请的，因此不会被 Runtime 扫描到。</li><li>realCap 和 realLen 用于控制 s 来实现类似 slice 的功能，因为 s 实际是定长的。</li><li>idxMap 是用于实现 map 能力的，其 k,v 都是 int，因此会被 Runtime 忽略（Go 1.5 开始提供此特性：<a href="https://go-review.googlesource.com/c/go/+/3288%EF%BC%89">https://go-review.googlesource.com/c/go/+/3288）</a></li></ul><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>我们使用 benchmark 来检验性能，并使用 Pprof 来观察堆情况</p><p>benchmark：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkEmap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>m := emap.NewGCEscapeMap(<span class="hljs-number">2000000</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>m.Push(i, TestAim&#123;<br>Str:    <span class="hljs-string">&quot;1&quot;</span>,<br>Map:    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;,<br>Value:  <span class="hljs-number">0</span>,<br>Str2:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str3:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str4:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str5:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str6:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str7:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str8:   <span class="hljs-string">&quot;1&quot;</span>,<br>Value2: <span class="hljs-number">0</span>,<br>Value3: <span class="hljs-number">0</span>,<br>Value4: <span class="hljs-number">0</span>,<br>Value5: <span class="hljs-number">0</span>,<br>Value6: <span class="hljs-number">0</span>,<br>Value7: <span class="hljs-number">0</span>,<br>&#125;)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>m.Get(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkNormalMap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]emap.Aim, <span class="hljs-number">1000000</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>m[i] = TestAim&#123;<br>Str:    <span class="hljs-string">&quot;1&quot;</span>,<br>Map:    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;,<br>Value:  <span class="hljs-number">0</span>,<br>Str2:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str3:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str4:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str5:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str6:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str7:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str8:   <span class="hljs-string">&quot;1&quot;</span>,<br>Value2: <span class="hljs-number">0</span>,<br>Value3: <span class="hljs-number">0</span>,<br>Value4: <span class="hljs-number">0</span>,<br>Value5: <span class="hljs-number">0</span>,<br>Value6: <span class="hljs-number">0</span>,<br>Value7: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>_ = m[i]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/img.png" class="" title="Benchmark 结果"><p>Pprof</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;()<br>time.Sleep(time.Second)<br>UseGCEscapeMap()<br><span class="hljs-comment">//UseNormalMap()</span><br>time.Sleep(<span class="hljs-number">1000</span> * time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UseGCEscapeMap</span><span class="hljs-params">()</span></span> &#123;<br>m := emap.NewGCEscapeMap[TestAim](<span class="hljs-number">2000000</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>m.Push(i, TestAim&#123;<br>Str:    <span class="hljs-string">&quot;1&quot;</span>,<br>Map:    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;,<br>Value:  <span class="hljs-number">0</span>,<br>Str2:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str3:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str4:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str5:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str6:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str7:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str8:   <span class="hljs-string">&quot;1&quot;</span>,<br>Value2: <span class="hljs-number">0</span>,<br>Value3: <span class="hljs-number">0</span>,<br>Value4: <span class="hljs-number">0</span>,<br>Value5: <span class="hljs-number">0</span>,<br>Value6: <span class="hljs-number">0</span>,<br>Value7: <span class="hljs-number">0</span>,<br>&#125;)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>st := time.Now()<br>runtime.GC()<br>fmt.Printf(<span class="hljs-string">&quot;GC took %s\n&quot;</span>, time.Since(st))<br>time.Sleep(time.Second)<br>&#125;<br><br>runtime.KeepAlive(m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UseNormalMap</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]TestAim, <span class="hljs-number">1000000</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>m[i] = TestAim&#123;<br>Str:    <span class="hljs-string">&quot;1&quot;</span>,<br>Map:    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;,<br>Value:  <span class="hljs-number">0</span>,<br>Str2:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str3:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str4:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str5:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str6:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str7:   <span class="hljs-string">&quot;1&quot;</span>,<br>Str8:   <span class="hljs-string">&quot;1&quot;</span>,<br>Value2: <span class="hljs-number">0</span>,<br>Value3: <span class="hljs-number">0</span>,<br>Value4: <span class="hljs-number">0</span>,<br>Value5: <span class="hljs-number">0</span>,<br>Value6: <span class="hljs-number">0</span>,<br>Value7: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>st := time.Now()<br>runtime.GC()<br>fmt.Printf(<span class="hljs-string">&quot;GC took %s\n&quot;</span>, time.Since(st))<br>time.Sleep(time.Second)<br>&#125;<br><br>runtime.KeepAlive(m)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>UseGCEscapeMap：</p><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/stdout-em.png" class="" title="UseGCEscapeMap输出结果"><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/heap-status-em.png" class="" title="UseGCEscapeMap堆状态"><p>UseNormalMap:</p><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/stdout-nm.png" class="" title="UseNormalMap输出结果"><img src="/2024/03/07/Go-GC-%E8%B0%83%E4%BC%98/heap-status-nm.png" class="" title="UseNormalMap堆状态">]]></content>
    
    
    <categories>
      
      <category>tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>End&amp;Start</title>
    <link href="/2024/02/23/End-Start/"/>
    <url>/2024/02/23/End-Start/</url>
    
    <content type="html"><![CDATA[<h1 id="End-Start"><a href="#End-Start" class="headerlink" title="End&amp;Start"></a>End&amp;Start</h1><p>立个 flag：这个周末写点东西～</p>]]></content>
    
    
    <categories>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hello-world</title>
    <link href="/2024/01/25/hello-world/"/>
    <url>/2024/01/25/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hyphen"><a href="#Hyphen" class="headerlink" title="Hyphen"></a>Hyphen</h1><p>This is a Hello World page</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello Wolrd!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Only For Hyphen</title>
    <link href="/2018/06/08/i-am-not-hyphen/"/>
    <url>/2018/06/08/i-am-not-hyphen/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5c427d07944d07618e7b8b3c26cef0aaba2e437ba6a4a291fac82573d0e9ad68">e32ff89d1b75ae8a97b4d649089b0415557849d44d6f7d9231c9cc419469499601104b083f3a91f72e88953950b3141825bc920cec6696baf4593bc2223f194b34f8496faa8a51f00931dbff76707d008c7a79a758b2c3a35cfa37d3b356b095e88f74ae58394bfba61c32f126a1af44281bddee701fe9b97eba181cb84019cdd3e77b826f22d921a1466936089f99ce835d8aa682ff411ac47948d71d0973bf74c7bec24334b492c4a53850d0db1c62b4059b2785fa300cb82c8b00796588a4cf7d52848a1a29e20e833c171ea628c25c1c05d11749c08dac204b975b47d5f8c77e900313abd3b18b39ea92dc55b4ff6830ede0a61dc2ad9b7fbceac42b1de6524c3ceaefb0ea9bca3441e316880b66a2ef45635054e103c2f9cf3a9d6d965c5128a62b9867e60dc70d320361aa06494c9e08b850ccd94864aef112afc00f474f6fef8ffdead71c20b93641abe3178eee04bfa2dd3e1215f4c0a70fc3f9f3e40585694523915d4a03cefa0d7c1ff21da1938dda865090eeacb07197b58199ddbf7fadf6f5f46b5c14a88ece793df59555b9bd2238941765ff4a60a8548715bc287dc2fb4443b9be3cf3face5eefdfd8d1b216899c423e5889bd2da3c34f10c0e1e71c666c6f8d99efb4bd83454db7a1b30b41afa0cb03274a73be11946a61c7cb1a5cbcb2afd608655691585bff0a1b73aea523e740750fd52362f437ddec3aeb88e2769857df662f04df6aec75bcefc4011dba9de39890659d5356af2f136083588607894187f99ebbe982a8bd1b34dfab6c512f99b111cbab8b3d87e0212d30826e931bc660639aa12ade00e7679d0452669c2168eaa72cbbc6c434ac8475c3c6b9116cbe7c7cb87001342a5b244777f8e92ca160256b23306014676aea2c1625a925eb5d441fbbf42e56015ec69ee1d6d687605c5d27a2b23782ae2a58388b66e98275303517ee5aee2c232875e47a89fb8319a4888dda79020bd259722529bf841fe18497b4cd9750bc62f54f23f6f51d6374bc4b7383aba231f3daf74a9574353f8701fc8233712c1c9308650d347ac3b7e96d72f018d7e643ffc1c48d66d62bc4eea686a6b2bc39dd2d74766a5fe83ed323a4a9e9e8edcb623ce3328aa97b8d819e4a152725a9cf02106c70861ecffc9849fab923fa1c41549ccd9ca914fb4b28ceb9fe0355df019ada09ef0407fdc24db9448b534777b376c31b6b1ff50ba5b925a8db45b21daac95c5d2f9b8fa3c43a84fcdd4fe6d52ca6f577b9df8b387317c5d9a7547fcddf48b7719a7db15194125b0f65663319db54f65867a96dd704817546da4e409e2a60ad1dbc8e40d1a1881e956b103e691465856119674cf2c0ea1e4e13141218458b423ebab4a4e8d63fe4c7a98c592867d12b9cfd84722885cf0615ff2328a6779a1b76d1a09a147c0c38a2b29f170c32f1bbe2afc951e9334232776e7ec142bf060fc4b3d7cfc3bb333abb1dba4aed8bb917bbd48ee6ca6d2344a152746c94ab0b1564275ff734e76e1fe9a4674933f2c08a613092ee660b3ea6d03f107d05b173fd50d967a42dea7c2c9c0067ef5e98e2d58387fdb19b540c654f34f57487d8eb69e507b79ce36cdf8c6b5a6d52c14facf84cf8cfc811ca3a0062ce2e8eaba251aa032676552c2c1c51fc2035b67d3e68fdf59972244ebb8fb1e0c85f6cbc574bd15e58fdcd9764498fc687c3e7de585151d408c55c7829d01ccad4d91e32b520aaca0e7654912fd8b1b7982ab32b0a01a904794b01d5da6cbef15b418a4f9fbbc45f7992b6eaae654feb2772bd7e3183f00032414871101f1f42dbc97370fc61168727cda57379e5c6e6b2dd78f137a462ce54e22797661222d2e9e8bb6d39686a900a0d08b728432e15f7ecf8a954f53ba4841b95820aad2a224beae55ed9c74fe391a76e5a204b35aa814b13d4e4ed9b6d55c889bb4649836ccfda9a2cca9df55244b8b350b89dd3074b787df464b3315c363fbd474365816376d02ab9838687a5e423</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="wobuguan">wobuguan</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>self</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
